/*
    05-树9 Huffman Codes (30 分)
    In 1953, David A. Huffman published his paper "A Method for the Construction of Minimum-Redundancy Codes", 
    and hence printed his name in the history of computer science.
    As a professor who gives the final exam problem on Huffman codes, 
    I am encountering a big problem: the Huffman codes are NOT unique. 
    For example, given a string "aaaxuaxz", 
    we can observe that the frequencies of the characters 'a', 'x', 'u' and 'z' are 4, 2, 1 and 1, respectively. 
    We may either encode the symbols as {'a'=0, 'x'=10, 'u'=110, 'z'=111}, 
    or in another way as {'a'=1, 'x'=01, 'u'=001, 'z'=000}, both compress the string into 14 bits. 
    Another set of code can be given as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, 
    but {'a'=0, 'x'=01, 'u'=011, 'z'=001} is NOT correct since "aaaxuaxz" and "aazuaxax" can both be decoded from
    the code 00001011001001. 
    The students are submitting all kinds of codes,
     and I need a computer program to help me determine which ones are correct and which ones are not.

    Input Specification:
    Each input file contains one test case. For each case, the first line gives an integer N (2≤N≤63), 
    then followed by a line that contains all the N distinct characters 
    and their frequencies in the following format:

    c[1] f[1] c[2] f[2] ... c[N] f[N]
    where c[i] is a character chosen from {'0' - '9', 'a' - 'z', 'A' - 'Z', '_'}, 
    and f[i] is the frequency of c[i] and is an integer no more than 1000. 
    The next line gives a positive integer M (≤1000), then followed by M student submissions. 
    Each student submission consists of N lines, each in the format:

    c[i] code[i]
    where c[i] is the i-th character and code[i] is an non-empty string of no more than 63 '0's and '1's.

    Output Specification:
    For each test case, print in each line either "Yes" if the student's submission is correct, or "No" if not.

    Note: The optimal solution is not necessarily generated by Huffman algorithm.
    Any prefix code with code length being optimal is considered correct.

    Sample Input:                   Sample Output:
    7                               Yes
    A 1 B 1 C 1 D 3 E 3 F 6 G 6     Yes
    4                               No
    A 00000                         No
    B 00001
    C 0001
    D 001
    E 01
    F 10
    G 11
    A 01010
    B 01011
    C 0100
    D 011
    E 10
    F 11
    G 00
    A 000
    B 001
    C 010
    D 011
    E 100
    F 101
    G 110
    A 00000
    B 00001
    C 0001
    D 001
    E 00
    F 10
    G 11

    核心算法：
    计算WPL
    int GetWPL(HuffmanTree T,int depth)
    {
        if(!T->Left&&!T->Right)return depth*T->Weight;
        else return GetWPL(T->Left,depth+1)+GetWPL(T->Right,depth+1);
    }
    对每位同学的提交，检查
        *长度是否正确，注意：Code[i]的最大长度为N-1
        *建树过程中检查是否满足前缀码要求

答案：(有两个样例没通过，尚需优化)
#include<iostream>
#define Maxchar 63
#define MaxStu 1000
#define MINDATA -1
using namespace std;
typedef struct HeapStruct_Huff* MinHeap;
typedef struct HuffmanNode* HuffmanTree;
typedef int ElementType;
struct HeapStruct_Huff{
    HuffmanTree *Elements;
    int Size,Capicity;
};
struct HuffmanNode{
    ElementType weight;
    HuffmanTree Left,Right;
};
MinHeap CreateMinHeap();
HuffmanTree CreateHuffmanTree();
void BuildMinHeap(MinHeap,int,const int* cf);
void InsertHeap(MinHeap,HuffmanTree);
HuffmanTree DeleteHeap(MinHeap);
HuffmanTree BuildHuffmanTree(MinHeap,int,const int* cf);
int HuffmanWPL(HuffmanTree,int);
void StuWPL(int,int,int*,string[][Maxchar],const int* cf);
bool isprefix(string*,int);
int main(int argc,char*argv[]) {
    char c;
    int n,stu,hwpl,swpl[MaxStu],char_freq[Maxchar];
    MinHeap H=CreateMinHeap();
    cin>>n;
    for(int i=0;i<n;i++)cin>>c>>char_freq[i];
    HuffmanTree T=BuildHuffmanTree(H,n,char_freq);
    hwpl=HuffmanWPL(T,0);
    cin>>stu;
    for(int i=0;i<stu;i++)swpl[i]=0;
    string stud[stu][Maxchar];
    StuWPL(stu,n,swpl,stud,char_freq);
    for(int i=0;i<stu;i++){
        if(!isprefix(stud[i],n)&&swpl[i]==hwpl)cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
}
HuffmanTree CreateHuffmanTree(){
    auto T=new struct HuffmanNode;
    T->Left=T->Right= nullptr;
    return T;
}
MinHeap CreateMinHeap(){
    auto H=(MinHeap) malloc(sizeof (struct HeapStruct_Huff));
    H->Elements= (HuffmanTree*) malloc(sizeof (HuffmanTree)*(Maxchar+1));
    H->Size=0,H->Capicity=Maxchar;
    H->Elements[0]=CreateHuffmanTree();
    H->Elements[0]->weight=MINDATA;
    H->Elements[0]->Left=H->Elements[0]->Right= nullptr;
    return H;
}
void InsertHeap(MinHeap H,HuffmanTree T){
    int i;
    for(i=++H->Size;T->weight<H->Elements[i/2]->weight;i/=2)
        H->Elements[i]=H->Elements[i/2];
    H->Elements[i]=T;
}
HuffmanTree DeleteHeap(MinHeap H){
    int parent,child;
    HuffmanTree minnode=H->Elements[1],tmp=H->Elements[H->Size--];
    for(parent=1;parent*2<=H->Size;parent=child){
        child=parent*2;
        if(child!=H->Size&&(H->Elements[child]->weight>H->Elements[child+1]->weight))child++;
        if(tmp->weight<=H->Elements[child]->weight)break;
        else H->Elements[parent]=H->Elements[child];
    }
    H->Elements[parent]=tmp;
    return  minnode;
}
void BuildMinHeap(MinHeap H,int n,const int* cf){
    int i,parent,child;
    for(i=1;i<=n;i++){
        H->Elements[i]=CreateHuffmanTree();
        H->Elements[i]->weight=cf[i-1];
        H->Size++;
    }
    for(i=H->Size/2;i>0;i--) {
        HuffmanTree tmp=H->Elements[i];
        for(parent=i;parent*2<=H->Size;parent=child) {
            child=parent*2;
            if(child!=H->Size&&(H->Elements[child]->weight>H->Elements[child+1]->weight))child++;
            if(tmp->weight<=H->Elements[child]->weight)break;
            else H->Elements[parent]=H->Elements[child];
        }
        H->Elements[parent]=tmp;
    }
}
HuffmanTree BuildHuffmanTree(MinHeap H,int n,const int* cf){
    HuffmanTree T;
    BuildMinHeap(H,n,cf);
    while(H->Size>1){
        T=CreateHuffmanTree();
        T->Left=DeleteHeap(H);
        T->Right=DeleteHeap(H);
        T->weight=T->Left->weight+T->Right->weight;
        InsertHeap(H,T);
    }
    T=DeleteHeap(H);
    return T;
}
int HuffmanWPL(HuffmanTree T,int deep){
    static int hwpl;
    if(T){
        if(!T->Left&&!T->Right)hwpl+=deep*T->weight;
        HuffmanWPL(T->Left,deep+1);
        HuffmanWPL(T->Right,deep+1);
    }
    return hwpl;
}
void StuWPL(int stu,int n,int* swpl,string stud[][Maxchar],const int* cf){
    int i,j;char c;
    for(i=0;i<stu;i++)for(j=0;j<n;j++)cin>>c>>stud[i][j];
    for(i=0;i<stu;i++)for(j=0;j<n;j++)swpl[i]+=cf[j]*(int)stud[i][j].size();
}
bool isprefix(string* stud,int n){
    int i;
    string maxstring;
    for(i=0;i<n;i++)if(stud[i].size()>maxstring.size())maxstring=stud[i];
    for(i=0;i<n;i++){
        int j=0;
        if(stud[i]!=maxstring&&stud[i][0]==maxstring[0])
            for(;stud[i][j]&&stud[i][j]==maxstring[j];j++);
        if(!stud[i][j])return true;
    }
    return false;
}
*/